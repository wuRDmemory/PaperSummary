# 深度滤波

## 深度滤波的基本思想

深度滤波算法把一个3D点的深度看作是由很多带噪声的观测进行滤波之后得到的值，不过相比于其他滤波方法，该方法把模型建立为高斯分布和均值分布混合在一起的模型，具体而言，对于一次测量而言有两种状态，一种是较好的测量，值基本上满足高斯分布；一种是较差的测量，值是一个范围$[Z_{min}, Z_{max}]$中的均匀分布，所以最终的模型建立为：
$$
p\left(x_{n} | Z, \pi\right)=\pi N\left(x_{n} | Z, \tau_{n}^{2}\right)+(1-\pi) U\left(x_{n} | Z_{\min }, Z_{\max }\right)
$$
其中$\pi$为较好测量的概率, $x_n$为当前帧的观测点(图像上)，$\tau_n$为当前帧与参考帧相对位姿引起的标准差，具体为假设偏差了一个像素点引起的测量误差。


## 深度滤波最终的求解量是什么

深度滤波最终求解的其实是深度$Z$以及对应的概率$\pi$，其中$Z$作为3D点的深度，而$\pi$表示该点是较好3D点的概率，通过该值我们可以滤除较多的不稳定点（相比于许多SLAM中采用先优化再剔除的方法，该方法应该更为合理，且引入BA中的外点更少）。

基于上述思想，深度滤波将要求解的量表示为一个Beta分布和高斯分布的联合分布，其中Beta分布求解该3D点稳定的概率，而高斯分布求解该3D点的深度，公式如下：
$$
q\left(Z, \pi | a_{n}, b_{n}, \mu_{n}, \sigma_{n}\right) :=\operatorname{Beta}\left(\pi | a_{n}, b_{n}\right) N\left(Z | \mu_{n}, \sigma_{n}^{2}\right)
$$

可以看到公式基本上很工整，$a_n,b_n$是Beta分布的参数，而$\mu_n, \sigma_n$表示高斯分布的参数。


## 深度滤波如何做————贝叶斯公式

经过上面的说明，深度滤波有了观测方程，同时也有了要更新求解的状态变量，那么剩下的就是迭代求解了，这里采用贝叶斯公式，如下：
$$
p\left(Z, \pi | x_{1} \ldots x_{N}\right) \propto p(Z, \pi) \prod_{n} p\left(x_{n} | Z, \pi\right)
$$

上式中的所有变量在之前都有介绍，这里不再赘述。可以明白的看到，这是一个很贝叶斯的方程，先验与似然的乘积等于后验，但是作为一个实时滤波，怎么能忍受在每次求解的时候都要用上前面所有的信息呢？所以我们必然想到的一点就是将上式展开，写作一次更新的形式：
$$
q\left(Z, \pi | a_{n}, b_{n}, \mu_{n}, \sigma_{n}\right) = C \times p\left(x_{n} | Z, \pi\right) q\left(Z, \pi | a_{n-1}, b_{n-1}, \mu_{n-1}, \sigma_{n-1}^{2}\right)
$$

其中C是一个归一化参数，这里不用特别关注。


## REFERENCE
<ol>
<li>Video-based, Real-Time Multi View Stereo</li>
</ol>