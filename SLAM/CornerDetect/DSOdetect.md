# DSO detector



## 特点

DSO是半稠密直接法的SLAM，其中在进行特征点提取的时候，完全依赖图像梯度的大小，超过设定阈值的点就会被认为是特征点，而DSO在阈值的选取上做了一些工作，使得提取到的点能够更好。



## 大致流程

与大多数的SLAM一样，DSO在提取特征点的时候，也会使用图像金字塔来在不同层级上提取特征点，不过在实际的过程中也是略有不同的，后面会详细介绍。总体来说，DSO的特征点提取（主要是coarseInitializer类中的setFirst的流程）有以下几个部分组成：

1. 构建图像金字塔；
2. 对每一层金字塔，求解x y方向上的梯度，同时记录每个点梯度的模的平方和；
3. 将第0层的图像拆分为n个32\*32的图像块，对每个图像块：
   - 对其中每一个点的梯度模长统计直方图，需要注意的是，作者认为梯度的模长大于48的话和48是一样的，也就是说梯度模长大于48的话一视同仁（恩，以后简单的可以用48作为阈值进行简单的程序编写啦！），这一步同时计算出整个块中梯度模长的总和SUM；
   - 根据上面的直方图获得该像素块的提取阈值，方法就像从一个从低到高的队列中取一个值来滤掉较低数据一样，DSO的作者就是对SUM取一个比例（程序中选择0.5，所以论文中又把这个值称作中值）X，之后对梯度模长直方图从小到大不停的累加，当累加值大于X的时候，就把刚超过的模长+7认为是阈值；
4. 对于每一个像素块，取周围加自己9宫格内的阈值的平均（程序中称为smoothThr，论文中称为region-adaptive threshold，这个地方个人认为还是比较好的，比如对于一个渐变的墙，如果仅仅依靠当前图像块的数据来得到阈值，那么可能黑色的地方也能提取出一些点，这是我们不期望的，但是一旦和周围的一些阈值平均一下的话，当前图像块的阈值就拉高了，不会出现“井底之蛙”的现象），由于我们在第2步中记录的是每个点的模长的平方和，因此这里取到的平均值要平方一下免得后面计算平方根；

这里我们可以稍微休息一下，看看我们得到了什么？1）图像金字塔；2）图像金字塔中每个点的x y方向梯度和梯度的模长；3）一个基于金字塔第0层得到的平滑的阈值；

其实到这个时候，按道理就可以进行特征点的提取了，但是作者为了使特征点具有分散和一致性的特点，在选择的时候也做了一些trick，主要的思想是这样的：

1. 把整个图像分为若干个d*d的块，在该图像块中找到一个梯度模长最大且超过阈值的点作为角点；
2. 把整个图像分为若干个2d\*2d的块（相当于在金字塔的1层分为d\*d的块），在其中找一个模长最大且超过阈值的点作为角点，需要注意的如果找到的点在a中有相应的d\*d的块中，则该点要舍弃掉，保证图像的每个d\*d块中仅有一个点；
3. 同理，把图像分为若干个4d\*4d的块（相当于在金字塔的2层分为d\*d的块），也是找一个模长最长且超过阈值的点，同时该点在金字塔1层和0层中的d*d块中不能有点；

这部分代码的实现还是很巧妙的（代码里面还有一个地方是把每个块分为16个方向进行方向上的分散），感兴趣的可以看一下，思路就是上面的思路，理论上来说，论文上将作者发现SLAM的整个过程一些纹理相对弱的点也会有益于结果，假如在一个渐变的墙上，在金字塔的0层上，可能永远不可能提出角点，但是一旦放在1层或者2层上，对比度就会稍微高一些，如果此时把阈值也稍微放低的话（程序中是0.75），就能提取出一些在**弱分界线**上的点，这些点对于追踪也会有益处。

最后，我们要看一下究竟得到了多少个点，如果多于期望的点数，就把d变得大一些，这样图像块的数量就少了；如果少了，就把d变得小一些，这样图像块的数量就多了；



经过上面的流程之后，我们就得到了基于金字塔第0层的一系列点，接下来还要在金字塔的上层进行点的提取，这部分步骤如下：

1. 将该层图像分为若干个d*d的块，在块中也是仅仅取一个点，该点的梯度模长要大于阈值；
2. 同时按照x, y, xy, yx的次序找最大，取其中响应值最大的点作为该图像块中的点；
3. 随后也是看点数的多少来调节d的大小；

不过这部分我没有理解的是作者给入的期望点数，似乎是金字塔层数越高，期望得到的点数越高；

